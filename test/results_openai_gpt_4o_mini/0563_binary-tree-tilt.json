{
  "problem": {
    "id": "563",
    "frontend_id": "563",
    "title": "Binary Tree Tilt",
    "description": "Given the root of a binary tree, return the sum of every tree node's tilt.\nThe tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child.\n \nExample 1:\n\n\nInput: root = [1,2,3]\nOutput: 1\nExplanation: \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\nExample 2:\n\n\nInput: root = [4,2,9,3,5,null,7]\nOutput: 15\nExplanation: \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\nExample 3:\n\n\nInput: root = [21,7,14,1,1,2,2,3,3]\nOutput: 9\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000\n\n",
    "difficulty": "Easy",
    "examples": [
      "[1,2,3]",
      "[4,2,9,3,5,null,7]",
      "[21,7,14,1,1,2,2,3,3]"
    ],
    "structured_test_cases": [
      {
        "input": {
          "root": "[1,2,3]"
        },
        "expected": "1"
      },
      {
        "input": {
          "root": "[4,2,9,3,5,null,7]"
        },
        "expected": "15"
      },
      {
        "input": {
          "root": "[21,7,14,1,1,2,2,3,3]"
        },
        "expected": "9"
      }
    ],
    "python_starter": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findTilt(self, root: Optional[TreeNode]) -> int:\n        ",
    "hints": [
      "Don't think too much, this is an easy problem. Take some small tree as an example.",
      "Can a parent node use the values of its child nodes? How will you implement it?",
      "May be recursion and tree traversal can help you in implementing.",
      "What about postorder traversal, using values of left and right childs?"
    ],
    "meta_data": {
      "name": "findTilt",
      "params": [
        {
          "name": "root",
          "type": "TreeNode"
        }
      ],
      "return": {
        "type": "integer"
      }
    }
  },
  "solution": {
    "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findTilt(self, root: Optional[TreeNode]) -> int:\n        self.total_tilt = 0  # Initialize total tilt\n\n        def subtree_sum(node):\n            if not node:\n                return 0  # Base case: if the node is None, return 0\n            \n            # Recursively get the sum of left and right subtrees\n            left_sum = subtree_sum(node.left)\n            right_sum = subtree_sum(node.right)\n            \n            # Calculate the tilt for the current node\n            tilt = abs(left_sum - right_sum)\n            self.total_tilt += tilt  # Add the tilt to the total\n            \n            # Return the sum of the current subtree\n            return left_sum + right_sum + node.val\n\n        subtree_sum(root)  # Start the recursion from the root\n        return self.total_tilt  # Return the total tilt",
    "explanation": "The provided solution uses a recursive helper function `subtree_sum` to calculate the sum of values in the subtree rooted at each node while also computing the tilt. \n\n1. **Base Case**: If the node is `None`, we return 0, which represents the sum of an empty subtree.\n2. **Recursive Case**: For each node, we calculate the sums of the left and right subtrees by calling `subtree_sum` recursively.\n3. **Tilt Calculation**: The tilt for the current node is calculated as the absolute difference between the left and right subtree sums. This tilt is added to a running total (`self.total_tilt`).\n4. **Return Value**: The function returns the total sum of the subtree rooted at the current node, which includes the node's value and the sums of its left and right children.\n\nThe overall time complexity of this solution is O(N), where N is the number of nodes in the tree, since we visit each node exactly once. The space complexity is O(H), where H is the height of the tree, due to the recursion stack. In the worst case (a skewed tree), this could be O(N), but in a balanced tree, it would be O(log N)."
  },
  "test_result": {
    "success": false,
    "output": "Execution error:\n"
  },
  "timestamp": "2025-04-01 18:01:24"
}