{
  "id": "283",
  "frontend_id": "283",
  "title": "Move Zeroes",
  "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\n \nExample 1:\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\nInput: nums = [0]\nOutput: [0]\n\n \nConstraints:\n\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n \nFollow up: Could you minimize the total number of operations done?",
  "difficulty": "Easy",
  "examples": [
    "[0,1,0,3,12]",
    "[0]"
  ],
  "structured_test_cases": [
    {
      "input": {
        "nums": "[0,1,0,3,12]"
      },
      "expected": "[1,3,12,0,0]"
    }
  ],
  "python_starter": "class Solution:\n    def moveZeroes(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        ",
  "hints": [
    "<b>In-place</b> means we should not be allocating any space for extra array. But we are allowed to modify the existing array. However, as a first step, try coming up with a solution that makes use of additional space. For this problem as well, first apply the idea discussed using an additional array and the in-place solution will pop up eventually.",
    "A <b>two-pointer</b> approach could be helpful here. The idea would be to have one pointer for iterating the array and another pointer that just works on the non-zero elements of the array."
  ],
  "meta_data": {
    "name": "moveZeroes",
    "params": [
      {
        "name": "nums",
        "type": "integer[]"
      }
    ],
    "return": {
      "type": "void"
    },
    "output": {
      "paramindex": 0
    }
  }
}